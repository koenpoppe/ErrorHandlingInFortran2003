! AUTOGENERATED_TYPES
! 
!   This program determines the available types and precisions 
!   that are supported by the selected compiler.
! 
! HISTORY
! 
!   20100305 KP - (find_real_kinds) Initial version
!   20110308 KP - (find_real_kinds) Added output
!               - (find_integer_kinds) Initial documentation
!               - (find_integer_kinds) Minimal value added (independant of representation)
!   20111115 KP - Initial version, adapting find_integer_kinds and find_real_kinds
! 
! AUTHOR
! 
!   Koen Poppe, Department of Computer Science,
!   Katholieke Universiteit Leuven, Celestijnenlaan 200A,
!   B-3001 Heverlee, Belgium
!   Email: Koen.Poppe@cs.kuleuven.be
!
program autogenerated_types
    implicit none
    
    ! Local variables
    integer, parameter :: unit = 26349
    integer, dimension(:), allocatable :: rs, ps
    integer :: i, width
    
    ! Open file and write header
    open(unit=unit,file="autogenerated_types.xml",status="unknown",action="write")
    write(unit=unit,fmt="(A)") "<?xml version=""1.0""?>"
    write(unit=unit,fmt="(A)") "<types>"
    
    ! Common types
    write(unit=unit,fmt="(A)") "    <type format=""L1"">logical</type>"
    write(unit=unit,fmt="(A)") "    <type format=""A20"">character(len=*)</type>"
    
    ! Integer types
    call find_integer_kinds( rs )
    do i=1,size(rs)
        write(unit=unit,fmt="(2(A,I0),A)") &
            "    <type format=""I", rs(i)+1, &
            """>integer(kind=selected_int_kind(", rs(i), "))</type>"
    end do
    
    ! Real/Complex types
    call find_real_kinds( ps, rs )
    do i=1,size(rs)
        ! Extra width for sign (+1), E+ (+2) 
        width = ps(i) + max(7, 3 + ceiling(log10(real(rs(i)))))
        write(unit=unit,fmt="(4(A,I0),A)") &
            "    <type format=""ES", width, ".", ps(i), &
            """>real(kind=selected_real_kind(", ps(i), ",", rs(i), "))</type>"
        write(unit=unit,fmt="(4(A,I0),A)") &
            "    <type format=""ES", width, ".", ps(i), &
            """>complex(kind=selected_real_kind(", ps(i), ",", rs(i), "))</type>"
    end do
    
    ! Close file
    write(unit=unit,fmt="(A)") "</types>"
    close(unit=unit)
    
contains

    !--------------------------------------------------------------------------
    ! find_integer_kinds
    !--------------------------------------------------------------------------
    
    subroutine find_integer_kinds( rs )
        integer, dimension(:), allocatable, intent(out) :: rs
        integer, parameter :: max_nb_kinds = 10
        integer, dimension(max_nb_kinds) :: kinds_found, rr
        integer :: test_kind, nb_kinds_found
        integer :: r, rmax, index
        logical :: added
        
        nb_kinds_found = 0
        rr = 0
        
        rmax = ceiling(log10(2.0)*256.0) ! 2^256 bits is about this decimal range
        
        do r = 1, rmax
            test_kind = selected_int_kind( r )
            if( test_kind >= 0 ) then
                call add_to_set( kinds_found, nb_kinds_found, test_kind, added, index )
                rr(index) = max(rr(index),r)
            end if
        end do
        
        allocate(rs(nb_kinds_found))
        rs = rr( 1:nb_kinds_found )
        
    end subroutine find_integer_kinds

    !--------------------------------------------------------------------------
    ! find_real_kinds
    !--------------------------------------------------------------------------
    
    subroutine find_real_kinds( ps, rs )
        integer, dimension(:), allocatable, intent(out) :: ps, rs
        integer, parameter :: max_nb_kinds = 10
        integer, dimension(max_nb_kinds) :: kinds_found
        integer, dimension(max_nb_kinds) :: pp, rr
        integer :: test_kind, nb_kinds_found
        integer :: p,r, pmax,rmax, index
        logical :: added
        
        nb_kinds_found = 0
        pp = 0
        rr = 0
        
        pmax = ceiling(log10(2.0)*256.0)
        rmax = 16383
        
        do p = 1, pmax
            do r = 1, rmax
                test_kind = selected_real_kind( p,r )
                if( test_kind >= 0 ) then
                    
                    call add_to_set( kinds_found, nb_kinds_found, test_kind, added, index )
                    pp(index) = max(pp(index),p)
                    rr(index) = max(rr(index),r)
                end if
            end do
        end do
        
        allocate(ps(nb_kinds_found),rs(nb_kinds_found))
        ps = pp(1:nb_kinds_found)
        rs = rr(1:nb_kinds_found)
        
    end subroutine find_real_kinds

    !--------------------------------------------------------------------------
    ! Miscellaneous
    !--------------------------------------------------------------------------
    
    subroutine add_to_set( set, set_size, element, added, index )
        
        integer, dimension(:), intent( in out ) :: set
        integer,               intent( in out ) :: set_size
        integer,               intent( in     ) :: element
        logical, optional,     intent(    out ) :: added
        integer, optional,     intent(    out ) :: index
        
        ! Default value for the added optional output argument
        if( present(added) ) then
            added = .false.
        end if
        
        ! Only add if no such element exists in the set
        if( all( set(1:set_size) /= element ) ) then
            
            if( set_size+1 > size(set) ) then
                print *," *** ERROR: could not add element to the given set: the set is full."
                return
            end if  
            
            set_size = set_size + 1
            set(set_size) = element
            
            if( present(added) ) then
                added = .true.
            end if
            
            if( present(index) ) then
                index = set_size
            end if
        else
            if( present(index) ) then
                do index=1,set_size
                    if( set(index) == element ) then
                        exit
                    end if
                end do
            end if
        end if
        
    end subroutine add_to_set

end program autogenerated_types